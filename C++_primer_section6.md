# C++ primer section6

## 函数

##### 如何调用函数：

```c++
int j = fact(5); //求5的阶乘
cout << j << endl;
```

函数的调用在主函数中完成两项工作：

1. 用**实参**初始化对应的**形参**（5对应val） 
2. 将控制权转移给被调用函数（main()-->fact()）

被调用函数的执行过程：

1. **定义并初始化形参**，当调用fact函数时，首先创建一个名为val的int变量（也就是说在定义函数的时候并没有创建val，所以说它是**形式参数**嘛，就是个形式，就跟一些空头[项目]()一样，根本没做）。 
2. 遇到一条return语句时，结束执行过程，return语句完成两项工作：  
   1. 返回return语句中的值 
   2. 将控制权还给主调函数

#### 形参和实参

 一句话：用实参按顺序初始化形参，所以啊，实参类型必须和对应的形参类型匹配：

```c++
//错误调用示例
fact("hey"); fact(); fact(42, 10);
//正确调用示例
fact(3.14) //等价于fact(3);隐式转换
```

##### 函数的形参列表

 可以为空：**是可以空的**

```c++
int f1(){ } //隐式定义空形参列表
int f2(void){ } //显式定义空形参列表
```

大多数类型都能用作函数的返回类型。一种特殊的返回类型为void，表示不返回任何值。 **函数的返回类型不能是数组类型（因为数组不能被拷贝）或函数类型（目前不知道为啥），但是我们有指针啊，可以返回指向数组或者函数的指针就好了（慢着，函数也有指针，有的啊，这章后面就会介绍）**

#### 局部对象

 大部分变量都是局部变量，因为我们小程序员不太敢污染全局空间，局部变量还有个神奇的地方：

```c++
int a = 0;
{
int a = 1;
cout << a << endl;
}
cout << a << endl;
```

你猜会报错吗？不会报错的话输出是啥？答案是**1 0**

##### 自动对象：只存在于块执行期间的对象称为自动对象，比如里面的a，还有我们的形参，都是自动对象。



##### 局部静态对象（只被定义初始化一次，可以一直用它）

有些时候，有必要让局部变量不销毁一直在，例如，下面的函数统计它自己被调用了多少次：

```c++
int count()
{
static int cnt = 0; //这个就是局部静态对象，这句话只在第一次调用时执行，
//而且调用结束后，这个值仍然有效，是不是很厉害啊
return ++cnt;
}
int main()
{
for(int i = 0; i<10; ++i)
{
  cout << count() << endl;
}
return 0;
}
```

补充一句，**如果静态变量没有显式的初始值，它将执行默认初始化**。

#### 函数声明和分离式编译

 函数和变量一样，名字必须在使用前声明，**定义一次，声明多次**，即制造一次，使用多次。 函数的声明和函数的定义非常类似，唯一的区别就是函数声明无须函数体，用一个分号代替：

```c++
int fact(int val); //函数三要素（返回类型，函数名，形参类型）描述了函数接口
//也就是说明了调用该函数所需的全部信息
```

说函数声明是啥目的呢？就是我们C++要支持**分离式编译**，在源文件中定义了一个函数，然后我们其他文件想去使用它（偷懒，自己不定义），所以我们要声明一下，你这个函数借我用一下，声明也同时告诉我们这个函数怎么用。 Plus： **定义函数的源文件还要把含有函数声明的头文件包含进来，目的是：编译器来验证函数的定义和声明是否匹配。**

## 参数传递

前面我们学过，每次调用函数的时候，都会重新创建它的形参，并用传入的实参去初始化它。记住这句话：**形参的类型决定了形参和实参交互的方式：** 

- 形参为引用：形参绑定到实参上，形参就是实参的绰号，是同一个人。 
- 形参为值类型（不加引用），形参和实参是两个独立的对象，只不过是实参的值拷贝给形参了。

**可以看出引用都不需要构造新对象，还可以改变原来的实参**

##### 使用引用避免拷贝

 对吧？前面减1那个函数要拷贝，我们这个置零函数就不用了，是不是省了很多啊。更重要的是，**有些类型是不支持拷贝的**，比如前面学的**数组**，那我们只能用引用传参了。 举个栗子：我们要写个函数比较两个string的长度，string可能会很长，所以我们不要拷贝，用引用传参：

```c++
bool isShorter(const string &s1, const string &s2) //为毛用const，尽量都得用它
{
  return s1.size() < s2.size();
}
```

**数组不能被拷贝！！！！**

#### const形参和实参

 来看一个很有意思的函数定义：

```c++
void f(const int i){}
```

我们当然可以给它传一个const int的类型，那么我们可以给它传一个int型的吗？要回答这个问题，我们要知道函数调用的时候参数是怎么过去的呢，其实值传递的话就是一个拷贝对吧，我把int的拷贝给const int的有什么不可以，这个你如果忘了的话，请回顾之前第二章的内容。再联系我们说过的一个概念，顶层const，即对象本身是常量，我们在拷贝时会忽略顶层const：

```c++
const int a = 1;
int b = a; //你看，忽略了吧
```

所以啊，如果我们在程序中再定义一个函数：

```c++
void f(int i){}
```

就会报错了，因为它跟之前带const的f函数重复了。

这里要注意的跟以前变量初始化的时候类似，我先写两个函数，然后我们来看看下列调用方式是否合法（就是看参数传递是否合法）：

```c++
void reset(int *p){} //我就写个壳子
void reset(int &p){} //重载函数
int main()
{
  int i = 42;
  const int ci = i;
  string::size_type ctr = 0;
  reset(&i); //正确：调用1（上面那个）
  reset(&ci); //错误：传入的是底层const，不能初始化int *
  reset(i); //正确：调用2
  reset(ci); //错误：不能把普通引用绑定到常量const上
  reset(42); //错误：理由基本同上
  reset(ctr); // 错误：类型不匹配
}
```

##### 尽量使用常量引用

 **只要不需要改变形参的值，都尽量用常量**，理由有两点： 

- **该用常量而不用常量，会给函数的调用者一种误导，即函数可以改变它的实参的值** 

- **使用引用而非常量引用会限制函数所能接受的实参类型。刚刚就学过，我们不能把const给非const的，但可以把非const的给const。**
- **使用普通引用作函数的形参，不能把 `const` 对象、字面值传递给普通的引用形参。**

看上面的例子中其实是这样的

**如果你把函数定义为按值传递，reset(42)没啥问题，不管你是const int 还是int,按值传递实际是进行了一个拷贝操作**

**但如果定义为了按引用传递，reset(42)就有问题了，因为引用并不执行拷贝，直接就用的是实参，而你的实参如果是const int（常量值），用int&去匹配他肯定是不行的**

#### 数组形参

 为什么要单独把数组的形参拿出来说呢，有两个原因： 

**数组不允许被拷贝：所以无法使用值传递** 

**使用数组名时会将其转换为指针。**

```c++
//以下三个函数声明等价（还记得函数声明吧）
void f(const int*);
void f(const int[]); //数组名转换为数组首元素指针
void f(const int[5]); //我们期望它有五个元素，其实都行
```

编译器在处理f函数调用时，只会检查传入的参数是不是const int*类型。 其实我们还漏了一点，因为数组是以指针的形式传给函数的，所以我们的被调函数不知道数组有多长，这个责任是调用者的，所以调用者应该提供一些额外信息来说明：

##### 使用标记指定数组长度

 C就是这样的，以前老师在教C的时候一定会说，不要忘了反斜杠零，它是结束标志，就是这个意思。有些像字符串什么的还是好用的，但是对于int这种所有取值都有效的就不适用了。

##### 使用标准库规范

 就是用**begin()和end():**这俩函数够老了...

```c++
void f(const int *beg, const int *end)
{
  while(beg != end)
  {
      cout << *beg++ << endl;
  }
}
//这样就把数组首和尾后信息都传进去了
//调用如下
int j[3] = {1, 2, 3};
f(begin(j), end(j));
```

##### 显式传递一个表示数组大小的形参

 就是多一个传入参数表示数组长度，easy老套。

##### 数组形参和const

 一句金玉良言：**当函数不需要对数组元素执行写操作时，数组的形参应该是指向const的指针；只有当函数确实要改变元素值得时候，才把形参定义成指向非常量的指针**

##### 数组引用形参

数组当然也可以引用绑定：

```c++
//这里的10形参，是数组类型的一部分，所以只接受10个元素的数组
void f(int (&arr)[10])
{
    for(auto elem : arr)
    {
        cout << elem << endl;
    }
}
```

##### 传递***数组

***数组就是数组的数组。和所有数组一样，在将***数组传递给函数时，真正传递的是**指向数组首元素的指针**。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针，要完全匹配才能调用。

```c++
void print(int (*matrix)[10], int rowsize){}
```

调用这个函数，第一个参数虽然是指针，但是**是指向数组的指针**，所以数组的维度也是数组类型的一部分，所以再调用的时候那个数字10也要完全匹配。



#### 含有可变参数的函数

有时候我们不清楚应该向函数传递几个实参，为了能处理不同数量的实参，C++提供了两种方法：

1. 如果所有的实参类型相同，则可以传递一个名为**initializer_list**的标准库类型。 

2. 编写可变参数模板（以后再介绍） 比如我们要写一个输出错误的程序，我们又不知道具体有多少错误，但是这些错误的类型输出都是string，于是：

   ```c++
   void errorMsg(initializer_list<string> il) //这个是类模板嘛
   {
    for(auto beg = il.begin(); beg != il.end(); ++beg)
    {
        cout << *beg << endl;
    }
   }
   ```

   我们可以用不同的参数数量去调用：

   ```c++
   errorMsg({"aaa", a, b}); //向initializer_list传递值序列要用花括号
   errorMsg({"a", "b"}); //不同数量的实参
   ```

   除了initializer_list表示的数量不定的同种类型的参数，当然还可以加其他类型的参数，另外加上就行。

   ```c++
   void errorMsg(int a, initializer_list<string> il)
   ```

看的出来这个和vector那种比较像，所以用花括号初始化

## 返回类型和return语句

##### 值是如何被返回的

1. 返回类型为值： 其实和初始化一个变量的方式完全一样，**返回的值会初始化一个临时的对象**，然后赋值给调用点。

   ```c++
   string plus(const string &word, const string &p)
   {
    return word + p;
   }
   ```

   该函数的返回类型是string，值类型，也就是说，返回值会被拷贝到调用点，这个函数在返回的时候会创建一个临时的string对象（内容是word+p），然后给调用点。 这样是不是很麻烦且浪费呢？我们当然可以不拷贝，怎么办呢，用引用啊 

2. 返回类型为引用：

   ```c++
   //返回两个string中较短的那个
   const string &shortStr(const string &s1, const string &s2)
   {
    return s1.size() <= s2.size() ? s1 : s2;
   }
   ```

```
graph LR
形参为引用-->调用函数时不用拷贝string对象
graph LR
返回类型为引用-->返回结果不用拷贝string对象
```

那么，是不是这么好用呢？你如果很注意细节的话当然是，但这个稍不注意就会出错，不信你看看下面的这个函数对不对：

```c++
//判断string是不是空的
const string &f()
{
    string ret;
    if(!ret.empty())
    {
        return ret;
    }
    else
    {
        return "empty";
    }
}
```

两处返回值都错了，**返回ret肯定错，因为ret是在被调用函数中定义的，当return之后ret都被销毁了**，怎么还能返回引用呢？那之前的怎么合法呢？因为人家不是自己定义啊，是主调函数传进来的。第二个也是同样的错误，**"empty"只是个在被调函数中临时创建的对象，return之后也是要销毁的**。 调用一个返回引用的函数得到左值（身份），其他返回类型得到右值（内容），所以啊，我们可以像使用其他左值那样来使用返回引用的函数的调用，**比如，可以给返回类型是非常量引用的函数的结果赋值**：

但是这里比较有疑问

一般来说，在函数内对于存在栈上的局部变量的作用域只在函数内部，**在函数返回后，局部变量的内存已经释放**。因此，**如果函数返回的是局部变量的值，不涉及地址，程序不会出错**；**但是如果返回的是局部变量的地址（指针）的话，就造成了野指针，程序运行会出错**，因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。

**我看错了，这里函数写的返回值就是引用！！！不是返回值，返回引用肯定是不行的啊，原来的对象都没了，引用个屁啊**

```c++
int &getVal(){}
int main()
{
    getVal() = 5; //这样是合法的
    return 0;
}
```

##### 列表初始化返回值：只不过是返回的数据类型复杂些：

```c++
vector<string> process()
{
    if(1)
    {
        return {}; //返回空vector对象
    }
    else
    {
        return {"你看不到我"};
    }
}
```

作者：苍井玛利亚
链接：https://www.nowcoder.com/discuss/19930
来源：牛客网



##### 列表初始化返回值：只不过是返回的数据类型复杂些：

```c++
vector<string> process()
{
    if(1)
    {
        return {}; //返回空vector对象
    }
    else
    {
        return {"你看不到我"};
    }
}
```

**看看老伙计main函数**

```c++
int main()
{

}
```

这样写会报错吗？它没有return语句啊，没事，**编译器会隐式插入一条return 0**; **返回0表示执行成功**，返回其他值表示执行失败，具体含义依机器而定。

```c++
int main()
{

}
```

这样写会报错吗？它没有return语句啊，没事，编译器会隐式插入一条return 0; 返回0表示执行成功，返回其他值表示执行失败，具体含义依机器而定。

#### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组，只能返回数组的指针或者引用。

```c++
int (*f())[10]; //函数返回的是指针，指向一个大小为10的int数组
```

因为这样看起来比较麻烦，我们可以用之前学过的类型别名：

```c++
using arr = int[10];
arr* f(); //这样的声明就比较简洁了
```

## 函数重载

这个东西我很喜欢的。 重载函数（overloaded）：**同一作用域**内的几个函数**名字相同且形参列表不同**：

```c++
//几个重载的函数声明
void print();
void print(int a);
void print(int a, int b);
void print(string a);
```

为什么要重载而不是直接用另外名字的函数呢？这个主要是为了方便调用者，因为比如，像上面这些函数，它们执行的操作都类似（print打印输出），调用者都只要调用print函数就好，**编译器会根据传递的实参类型来推断具体是哪个函数**。
 *main函数不能重载（* ~~ *还想上天啊* ~~） 再强调一遍：**对于重载的函数来说，形参数量或形参类型一定有所不同，不包括返回类型啊少年。** 

```c++
int f();
double f(); //错了，除了返回类型外都相同，不是重载了，再说了，你让编译器怎么办
```

==const来搞事情了==

##### 重载和const形参

一句话概括：**顶层const（本身为常量）**重载不行的，会被忽略，什么意思呢，看代码：

```c++
int f(int);
int f(const int); //重复声明，顶层const会被忽略
```

**底层const重载**是可行的：

```c#
int f(int&);
int f(const int&) //重载，常量引用都是底层const

int f(int *a);
int f(const int *a); //重载，指向常量的指针
```

**看来顶层const和底层const的定义还是有点用的....**

**const_cast和重载：**

```c++
//返回两个string中较短的那个
const string &shortStr(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

**这个函数很好用，可以接收常量也可以接收非常量**，但它有一个小小的不足，**当它就收两个非常量时，我们希望返回的也是非常量，而它还是返回常量引用**，所以我们要用const_cast写一个重载的函数：

```c++
string &shortStr(string &s1, string &s2)
{
    auto &r = shortStr(const_cast<const string>(s1), 
                        const_cast<const string>(s2));
    //强制转换s1和s2为const，再调用上面那个shortStr函数
    return const_cast<string&>(r);
    //去掉常量，返回普通引用
}
```

这样就好了。这里不用担心局部变量了，r肯定是s1,s2中的一个，所以肯定存在的

## 默认实参

假如，我们现在要用一个string表示一个窗口，一般情况下，**我们是希望窗口的高、宽是默认的**：

```c++
//窗口函数的声明如下，带默认实参
string screen(int height = 24, int w = 80);
```

在上面的函数，我们为每一个形参都提供了默认实参。**我们可以为一个或多个形参定义默认值，注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值**。

```c++
int f(int a = 24, int b); //这样的声明就是错误的
int f(int a, int b = 24); //这样就可以
```

##### 默认实参声明

**可以多次声明同一个函数**（跟我们之前介绍的一样），但是，**在给定的作用域中一个形参只能被赋予一次默认实参**：

```c++
string screen(int height, int w = 24);
string screen(int height = 24, int w = 24);
//错误：重复默认实参w，即便是同一个值也不行哦
string screen(int height = 48, int w); 
//正确，看上去height有默认实参，而它右边的w没有，但是
//w在第一行那个函数中已经有了啊
```

##### 默认实参初始值

下面我会写一些看着有些神奇的代码，让你猜输出什么，你只要记住这句话就不难了：**用作默认实参的名字在函数声明所在的作用域内解析**：

```c++
int a = 1;
int b = 2;
void f(int m = a, int n = b)
{
    cout << m << "," << n << endl;
}
void callf()
{
    a = 5;
    int b = 6;
    f();
}
int main()
{
    callf();
    return 0;
}
```

答案是：5,2

#### 内联函数和constexpr函数

现在我们可能觉得调用函数很方便，让某个函数实现一个功能，我们再去调用它就很爽，不用管里面的逻辑，但它也有缺点：**调用函数比直接在主函数里面写逻辑要慢，因为调用前要保存寄存器，在返回时恢复；可能需要拷贝实参；控制权转换**。

##### 内联函数可以避免函数调用的开销

将函数指定为内联函数，其实就是把函数调用的东西省略，直接把逻辑代码贴上去，例如我们之前写过一个比较字符串大小的函数：

```c++
cout << shortStr(s1, s2) << endl;
//如果把这个函数写成内联函数，那这个调用等价于
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
//这样就消除了shortStr函数的运行时开销
```

其实就是加个关键字inline：

```c++
inline const string &shortStr(const string &s1, const string &s2)
{
    return s1.size() < s2.size() ? s1 : s2;
}
```

那有人就会说，为什么不把所有的函数都定义成内联函数呢？这个我也不知道，可能是函数逻辑太多，在主函数中展开的话会有问题吧（知道的同学求赐教啊） 一般来说，**内联机制用于优化规模较小，流程直接，频繁调用的函数**

##### constexpr函数(真的没咋使过)

constexpr函数是指能用于常量表达式的函数，定义它要遵守一些规定：**函数的返回值类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：** 

```c++
constexpr int new_sz() {return 42;} //constexpr函数定义
constexpr int f = new_size(); //正确的调用
```

 **执行f的初始化时，编译器会直接把constexpr函数的调用替换成其结果值，就是42；为了能在编译过程中随时展开，constexpr函数直接被隐式地指定为内联函数。** 其实啊，我们也允许constexpr函数的返回值不是一个常量（破规定好多）：

```c++
constexpr int scale(int cnt){return new_sz() * cnt;}
```

**当scale的实参cnt是常量表达式时，返回值new_sz() * cnt也是常量表达式**；反之则不然：

```c++
int arr[scale(2)]; //对的
int i = 2;
int a2[scale(i)]; //错了
```

 **所以啊，constexpr函数不一定返回常量表达式** plus：**和其他函数不同，内联函数和constexpr函数可以在程序中多次定义，因为你要展开的话肯定要定义的，声明是不够的，但是定义得合法，上面已经说过怎么合法了，所以我们把内联函数和constexpr函数都放在头文件里。**

## 调试帮助

程序可以包含一些代码，只是用于调试的，发布的时候要屏蔽，这里介绍两个：**assert和NDEBUG**。

##### assert预处理宏

```c++
assert(expr);
```

**首先对expr求值，如果为假（0），assert输出信息并终止程序的执行；如果为真，assert什么也不做。 我觉得是很好用的，相当于可以帮你检查你所要检查的任何表达式的真假，还不会出大的错，用起来很放心。**

##### NDEBUG预处理变量

**因为类似assert的运行时检查依赖于NDEBUG的预处理变量状态**，所以在不用检查的时候，可以定义NDEBUG来避免检查各种条件所需的运行时开销，因为此时根本就不会检查，你的assert什么的都没用。 由此可见，C++赋予了程序员极大的权力与自由，同时也有些复杂。想使用它的同学自己去看用法吧，我一般不用就不介绍了。

## 函数匹配

#### 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分了五个等级

##### 1：精确匹配：

- 实参类型和形参类型相同 

- **实参从数组类型或函数类型转换为对应的指针类**型，数组类型转换为指针我们之前就学过，函数类型转换为指针我接下来也会讲，不要急 

- **向实参添加顶层const或者从实参中删除const，因为const可以赋值给非const**

  ##### 2：通过const转换实现的匹配

  ```c++
  int i = 0; //假定为实参
  const int &j = i;; //非常量转换为常量引用
  //等价于下面的函数调用过程
  void f(const int &j){}
  int i = 0;
  f(i);
  ```

  ##### 3：通过类型提升实现的匹配

  ```c++
  void f(double i){}
  int j = 0;
  f(j);
  ```

  ##### 4：通过算术类型转换或指针转换

  ```c++
  char a = 'a';
  void f(int a){}
  f(a); //char->int
  //指针转换主要指void指针可以和任意类型的指针互相转换
  ```

#####        5：通过类类型转换实现的匹配（以后介绍）

我们来看个例子：

```c++
void f(int &); void f(const int &); int a = 1; const int b = 0;
f(a); //调用f(int &) f(b); //调用f(const int &) //其实f(a)也可以调用const，但是人家有完全匹配的啊
```

### 函数指针

 **函数指针指向的是函数，不是对象哦。和其他指针一样，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型决定，与函数名无关。** 来看一个函数作为示例：

```c++
//比较两个string对象的长度 bool lengthCompare(const string &, const string &);
```

根据函数类型的定义，该函数的类型是bool(const string &, const string &)。要想声明一个可以指向该函数的指针，只需用**指针替换函数名**即可：

```c++
//pf指向一个函数，该函数的形参是两个const string的引用，返回类型是bool bool (*pf)(const string &, const string &); //没有初始化的指针
```

直接看这个pf，怎么看出它是什么类型呢： 1. pf前面有个*，表示它是个指针 2. 右侧是形参列表，表示pf指向的是函数 3. 再看左边，发现函数的返回类型是bool 综上所述：pf是一个指向函数的指针，这个函数的参数是两个const string的引用，返回类型是bool ++pf两边的括号不能少，如果少了的话，bool *pf(const string &, const string &);就是一个返回值为bool* 的函数++

#### 使用函数指针

当我们把函数名作为一个值使用时，**该函数自动转换为指针（是不是和数组很相似啊）**：

```c++
pf = lengthCompare; //pf指向名为lengthCompare的函数 pf = &lengthCompare; //等价的
```

**这里一开始很疑问，后来查了一下发现函数指针真的和数组指针很像，名字可以当指针使，当然不能是左值**

**我们可以通过指针来访问函数，也就是说，我们可以借助pf来调用lengthCompare函数：**

```c++
bool b1 = (*pf)("hello", "Jay"); //普通青年这么写 bool b2 = pf("hello", "Jay"); //二比青年这么写，也对 bool b3 = lengthCompare("hello", "Jay"); //这么写最传统
```

 **指向不同函数类型的指针间不存在转换规则~** 不过，我们可以为任意类型的函数指针赋值一个nullptr或0来表示该指针没有指向任何一个函数：

```c++
pf = 0;
```

#### 函数指针作为形参

这个高级了，看起来非常六：

```c++
void f(bool (*pf)(int));
```

怎么样，看起来是不是很吊，感觉像写错了，其实，这里声明了一个f函数，后面那一堆就是f函数的形参，只不过形参比较复杂，是一个**函数指针**，这个指针指向的函数类型是形参为一个int返回类型是bool。 装逼的人也可以这么写，和上面是等价的：

```c++
void f(bool pf(int)); //pf会自动转换为指向函数的指针
```

我们也可以**直接把函数作为实参使用**，因为我们在使用函数名的时候，编译器会帮我们转换为指针：

```c++
void useBigger(const string &, const string &, bool (*pf)(const string &, const string &)); //先声明函数 useBigger(s1, s2, lengthCompare); //使用函数，用函数名调用
```

是不是觉得声明函数很长很烦呢，我们可以用神器typedef：

```c++
typedef decltype(lengthCompare) *Func; //先用decltype把函数lengthCompare的类型返回，然后让Func与这个类型的指针等价， //也就是说Func指向和lengthCompare一样的函数类型 //现在我们就可以简单声明了 void useBigger(const string &, const string &, Func);
```

#### 函数指针作为返回值

说完了函数指针作为形参，现在来说作为返回值。和数组类似，**我们不能返回函数，但是可以返回函数指针**。这里我们就要老老实实把返回类型写成指针，不能用前面的装逼写法了（~~其实一直不装逼比较好~~）：

```c++
using F = int(int*, int); //F是函数类型 using PF = int(*)(int*, int); //PF才是函数指针类型
```

为了方便，我直接使用了类型别名，应该好理解的。 根据返回类型来判断几个表达式：

```c++
PF f1(int); //对 F f2(int); //错 F *f3(int); //对
```

好判断把，只要记住只能返回函数指针不能返回函数就好，为什么我们要用类型别名呢？来，看一个不用类型别名的：

```c++
int (*f1(int)(int*, int)); //等价的f1
```

\1. f1有形参列表(int)，f1是个函数 2. f1前面有*，返回的是指针 3. 指针类型本身也包含形参列表(int*, int)，所以指针指向函数 4. 该函数的返回类型是int，形参列表为(int*, int) 所以啊，还是用类型别名吧，程序员何苦为难程序员 当然，返回类型复杂的时候我们可以使用尾置返回类型：

```c++
auto f1(int) -> int (*)(int*, int);
```

个人推荐尾置和类型别名。