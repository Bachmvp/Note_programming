# C++ tips

## C++ std::move()

在C++11中，标准库在<utility>中提供了一个有用的函数std::move，std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

std::move函数可以以非常简单的方式将左值引用转换为右值引用。(左值 右值 引用 左值引用)概念 https://blog.csdn.net/p942005405/article/details/84644101

1. C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
2. std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。
3. 对指针类型的标准库对象并不需要这么做.

## 数学计算函数

```c++
 double log10()
 double fmod(double a,double b) 计算浮点数的余数，就是看小数位后面的数字，可以用来判断整数
```

int rand() 生成随机数

## accumulate

求和函数，做算法题的时候使用比较方便

```c++
int sum = accumulate(vec.begin() , vec.end() , 42);  第三个参数就是多加的东西
string sum = accumulate(v.begin() , v.end() , string(" "));  
```

## 二分查找的函数

```c++
#include <algorithm>
```

二分查找的函数有 3 个：

#### lower_bound

(起始地址，结束地址，要查找的数值) 返回的是数值 **第一个** 出现的位置。

功能：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回**大于或等于val的第一个元素位置**。如果所有元素都小于val，则返回last的位置.

注意：如果所有元素都小于val，则返回last的位置，且last的位置是**越界**的！！

#### upper_bound

(起始地址，结束地址，要查找的数值) 返回的是 第一个大于待查找数值 出现的位置。

功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回**大于val**的第一个元素位置

注意：返回查找元素的最后一个可安插位置，也就是“元素值>查找值”的第一个元素的位置。同样，如果val大于数组中全部元素，返回的是last。(注意：数组下标越界)

#### binary_search

(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个**bool值**。

注意：使用二分查找的前提是数组有序

使用的时候要小心，但可以看出lower和upper的区分就是判断条件>=还是>

## 求前缀和的方便函数 partial_sum

```c++
#include <numeric> 头文件
template <class InputIterator, class OutputIterator, class BinaryOperation>
OutputIterator partial_sum (InputIterator first, 
                            InputIterator last,
                            OutputIterator result, 
                            BinaryOperation binary_op);
```

**partial_sum 对于序列 a,b,c,d 产生序列 a,a+b,a+b+c,a+b+c+d。**

output的容器一定要足够大才行，也可以用input的first

## C++ 位操作

异或 相同false 不同true

与，或正常

两个数字按照二进制，对每一位进行比较

位运算是指按二进制进行的运算。在程序中，常常需要处理二进制位的问题。C/C++语言提供了6个位操作运算符。这些运算符只能用于整型操作数，即只能用于带符号或无符号的char,short,int与long类型。

在实际应用中，建议用unsigned整型操作数，因为带符号操作数可能因为不同机器结果不同。

x ^ 0s = x             x & 0s = 0           x | 0s = x
x ^ 1s = ~x           x & 1s = x           x | 1s = 1s
x ^ x = 0               x & x = x             x | x = x  

返回的值不止0，1。比较所有位之后得到结果

位操作，左移<<，右移>> 对变量进行位操作，并不会改变这个变量的值，只有通过赋值才能得到移动后的数值。

```c++
a>>2 a不变
a>>=2 a才是变了
```

1.反转的技巧，左移右移用&1

2.异或的技巧 交换律和^0

1. 交换律：a ^ b ^ c <=> a ^ c ^ b
2. 任何数于0异或为任何数 0 ^ n => n
3. 相同的数异或为0: n ^ n => 0

```c++
a = [2,3,2,4,4]
2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3
```

## char* char[] 和string

```c++
char* s="abcds";
```

abcds是一个常量，声明一个字符指针指向他的第一位

但之后对s无法操作，因为它指向的是个常量！s[0]='f';就是错的

```c++
char s[3]={'a','b'};要多一个空间装终止符
char s[]="abcdehf";这里就不用写多少个了，编译器会自动帮你做
```

这个就可以进行操作了，因为在栈上开辟了空间给s

### malloc&free

这里引申到另一种的声明方法，用动态申请内存

malloc的全称是memory allocation，中文叫动态内存分配。

```c++
void *malloc(int size); 
```

说明：malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 　　
备注：void* 表示未确定类型的指针，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者...）

```c++
void free(void *FirstByte)：
```

 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。

然后注意右malloc，后面必须free掉，而且一对一。**释放后应该把指向这块内存的指针指向NULL**

```c++
char* s=(char*)malloc(10+1); 如果想要是个字符的长度，后面加个终止符的空间，因为很多函数会要求识别终止符
```

需要说明的是:字符数组并不要求它的最后一个字符为′\0′,甚至可以不包含′\0′｡ 如以下这样写完全是合法的:

```c++
char str[5]={′C′,′h′,′i′,′n′,′a′};
```

是否需要加′\0′,完全根据需要决定｡但是由于C++编译系统对字符串常量自动加一个′\0′｡因此,人们为了使处理方法一致,便于测定字符串的实际长度,以及在程序中作相应的处理,在字符数组中有效字符的后面也人为地加上一个′\0′｡

### new&delete

动态创建对象时，**只需指定其数据类型，而不必为该对象命名**，new表达式**返回指向该新创建对象的指针**，我们可以**通过指针来访问此对象**。

那么C++的这个动态申请和C的动态申请的区别主要是

1. **new 返回指定类型的指针，并且可以自动计算所需要大小。**而 **malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。**
2. 对于**非内部数据类型的对象**而言，光用maloc/free无法满足动态对象的要求。**对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。**由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。



## Reverse

**函数功能**：将序列[first,last)的元素在原容器中颠倒重排，包含在algorithm库中。

- reverse()函数无返回值，时间复杂度O(n)。
- 可以看到函数中是last是先减一。应当理解的是vector.end()是指向数组最后一个元素后面的位置。
- reverse(v.begin(), v.end())即可实现全数组的反转。

## 递归和迭代

其实在实现算法中，一般递归和迭代都可以完成目的。但是各有各的优点和缺点

递归代码很简洁，但是不易理解，并且需要调用自身，函数调用是有时间和空间的消耗的，每一次函数调用都要在内存栈中分配空间来存储参数，返回地址和临时变量等等，而且数据向栈中的压入和弹出又会消耗时间。同时递归会产生大量重复计算，而迭代就可以借助记忆表来规避这里，其实动态规划就是这样。递归的次数太多容易造成栈溢出。

迭代代码比较繁琐，而且对于深度搜索遍历这种还需要借助栈的使用，但是比较直观，而且没有调用函数的消耗。