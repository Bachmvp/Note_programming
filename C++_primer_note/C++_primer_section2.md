# C++ primer section2

## 变量和基本类型

C++不仅定义了几种常用的基本内置类型（char, int, double等），更牛逼的是为程序员提供了**自定义数据类型**的机制，就是说你想怎么创造数据类型就怎么创造

常用内置类型如下

| 类型        | 含义           |
| ----------- | -------------- |
| *bool       | 布尔类型       |
| char        | 字符           |
| wchar_t     | 宽字符         |
| char16_t    | Unicode字符    |
| char32_t    | Unicode字符    |
| short       | 短整型         |
| *int        | 整型           |
| long        | 长整型         |
| long long   | 长整型         |
| float       | 单精度浮点数   |
| *double     | 双精度浮点数   |
| long double | 拓展精度浮点数 |

 **同一类型的数据在不同机器上所占的内存是不一样的**

内置类型的机器实现 大多数计算机以2的整数次幂个比特作为块来处理内存，下面区分两个概念

- **字节（byte）**，可寻址的最小内存块，就不会比字节还小了，没有四个位去寻的
- **字（word）**，存储的基本单元，通常由几个字节组成 例如：在一个字节为8比特，字为32比特（4字节）的机器上，我们可能看到一个字的内存区域如下： 

| 字节的地址 | 字节中具体内容  |
| ---------- | --------------- |
| 736424     | 0 0 1 1 1 0 1 1 |

意思就是这个内存块的地址（即可寻址内存块）是736424，它是4字节的，这个内存块存储的内容是0011，1011一个字节8比特。 通常，float 1个字， double 2个字， long double3个或4个字。

也就是float是32bit,double是64bit,long double是128bit

**带符号类型和不带符号类型**

带符号类型可以表示正数，负数或0，可以理解为带的符号就是正负号，无符号类型只能表示非负数，毕竟不让带符号，默认就是正号了。 例如 unsigned long。有个小规定是**unsigned int**可以缩写为unsigned，这个是最常用的。

**类型转换**

```c++
bool b = 42; //b为真，除非b=0，其他均为真
int i = b; //i=1,因为b是true，对应的int就是1，注意原来的42早就木有了
int a = 3.66; //a=3,注意不是四舍五入，而是直接舍弃
double c = a; //c=3.0

unsigned char m1 = -1;//m1=255,
signed char m2 = 256;//无定义
```

当我们给一个无符号数赋予一个超出它表示范围的值时，只要对它总数取模算出余数就好，在这里，8比特unsigned char表示0-255区间，总数为256，-1对256去模为255。 m2无定义 我们要避免给带符号类型赋值超过它表示范围的数。

```c++
int a = 1;
double b = 2.5;
cout << a+b << endl; 
//3.5，当碰到+/-等运算符，都会把小范围的数转成大范围的,int->double，
//主要目的是保证不损失精度
```

有符号无符号不要混用，实在要用先进行转换

在c++中，如果表达式中同时有无符号类型和有符号类型，会默认将**有符号类型**转换为无符号类型进行运算，运算结果也是**无符号类型**。int转unsigned int

#### 字面值常量

| 内容  | 字面值常量     |
| :---- | :------------- |
| true  | 布尔类型字面值 |
| 1     | 整型字面值     |
| 1.0   | 浮点型字面值   |
| '1'   | 字符字面值     |
| "1.0" | 字符串字面值   |

**变量初始化**

首先是很容易弄混的**赋值初始化**

```c++
int c = 1;//用等于号初始化
c = 2;//先把原来的1擦除，赋值2
```

初始化不是赋值，初始化是创建变量时赋予它一个初始值；赋值是把变量当前的值擦除，以一个新的值代替。

**列表初始化**

```c++
int d{0}; //等价于int d = 0, 也等价于int d(0)
```

使用花括号{}来初始化有一个很6的地方（当它跟类型转换混一起的时候），它不允许你丢失信息，听不懂的话下面举例说明：

```c++
double pi = 3.14;
int p1{pi}, p2 = {pi};//错误：列表初始化不允许损失信息
int p3(pi), p4 = pi;//正确：转换执行，且确实丢失了部分信息
```

其实是这样的，直接列表初始化，像这里用int装一个double肯定是不行的，编译器不允许这样，连强制转化也不会帮你做

但底下的初始化方式就可以，一个直接初始化（这里还没讲到），一个赋值初始化

**默认初始化**

程序员没有对a明确的初始化，则编译器默认初始化其为0，不同类型的变量默认初始化的值也不一样，那我们要不要去记住哪些变量类型对应的默认初始化值是多少呢？不用记，最好的办法就是我们不要默认初始化，每次定义一个变量，就赋给它一个初值。

##### 变量声明和定义的关系

为了支持**分离式编译**（暂时可以理解为程序可以拆分为多个文件，然后一起编译），C++语言将**声明**合**定义**区分开：

- 声明：使得名字为程序所知
- 定义：负责创建与名字关联的实体

```c++
extern int i; //声明i,声明一个变量就在它前面加上关键字extern，且不要初始化
int j; //声明并定义j
extern int k = 0; 
//定义k，因为赋予了初值，所以等价于int k = 0;
//但是你在函数体内部不能这么干，包括main函数，会报错
//所以，还是老老实实用前面两种方式吧
```

 **如果要在多个文件中使用同一个变量，就必须将声明和定义分离。变量的定义只能出现在一个文件中，其他用到该变量的文件必须对其声明，不能重复定义。** 可以这么理解：**定义是创建实体**，实体只有一个，我们定义了一个变量，就创造了一个工具，比如说一个榔头，然后我们在其他文件中想要用榔头，那就喊榔头一声，就声明一下。 所以啊，变量只能被定义一次，**但可以被多次声明**；对应着工具只需要创造一次，但可以被多次使用。

***C++是一种静态类型语言，在编译阶段检查类型。***

### const限定符 

 有时候，我们希望定义这样一种变量，它的值不能被改变。例如我们想用一个变量表示圆周率，当然它是一个不需要变得变量。 

```
const double pi = 3.14;
```

 只要在定义变量的时候前面加上关键字const就行了。
 **记住一点：const对象一旦创建后其值就不能再改变。** 因为你记住的这一点，所以**const对象必须初始化**。为什么有这个逻辑呢，因为你不能改变const的值，而你在定义的时候又没有给它一个初值，那要它干嘛？ 

```c++
const int i = 0; //正确：编译时初始化
const int j; //错误：k是一个没有被初始化的常量
```

**如果想在多个文件之间共享运行时初始化的const对象，必须在变量的定义之前添加extern关键字。** 理解这句话并不是很容易，你可以选择记住它，并跳过解释，解释如下： 

 当以编译初始化的方式定义一个const对象时，等一下，先解释什么是**编译初始化** 

> ```c++
> const double pi = 3.14; //编译时初始化，因为C++是静态类型语言，在编译阶段检查类型
> const int j = get_size(); //运行时初始化，因为编译器得在运行时调用函数才知道j是多少
> ```
>
> 解释完了，回到主题，当**编译器编译初始化**const对象的时候，**会在编译过程中把用到该变量的地方都替换成对应的值**，就是说代码里面pi在编译后都直接变成3.14，为了执行上述替换，编译器就必须知道变量的初始值。问题来了，如果程序包含多个文件，则每个用了const对象的文件都必须访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义

那这样的话C++的设计者怎么解决这个问题呢？答案就是各管各的，默认情况下，const对象被设定为仅在文件中有效，其他文件要用的话，自己再定义一个，这样不算重复定义，因为它只在本文件有效，是不是很耍赖啊，不过反正const对象不多，这么做也可以。 如果是运行时初始化呢？那问题就简单了 

```c++
//在j.cpp定义并运行时初始化一个常量
extern const int j = get_size();
//j.h头文件，声明一下就可以用了
extern const int j;
```

 这个**运行时初始化const**为什么可以一次定义多次声明呢？我的理解：**因为它本身就不是在编译的时候去替换值得**，所以不要紧，那它跟之前的普通变量一次定义多次声明有什么区别呢？你应该发现了，不管是定义还是声明，它都加了extern，为什么要加extern呢，因为之前不是规定默认情况是只在文件内有效吗，你加个extern（extern的英文意思就是外部的），就可以在其他文件，也就是外部文件来访问了。

<font size=5>**const的引用**</font>

把引用绑定到const对象上，我们称之为对常量的引用，与普通引用不同的是，对**常量的引用不能被用作修改它所绑定的对象**。 

```c++
const int ci = 12;
const int &r1 = ci; //正确：引用是常量，引用的对象也是常量
r1 = 42; //错误：r1是对常量的引用，不能修改它的值
int &r2 = ci; //错误：试图让一个非常量引用指向一个常量对象
```

 可能会对最后一句代码有疑惑，可以这么理解，你用了变量r2去引用一个常量对象，那我是不是可以通过r2去改变ci呢，可以的话，ci被改变，不符合ci是常量这一限定，不可以的话，r2本身是变量，凭什么不让我改，所以C++设计者索性让这个直接报错。

**其实也就是 int& 是引用，const int& 是常量引用，引用不能去引用常量对象，常量引用可以去引用常量对象，但是常量引用不能用来常量对象的值**

```
graph LR
非常量引用-->非常量对象
graph LR
常量引用-->常量对象
graph LR
常量引用-->非常量对象
```

 以上三种都是合法的，第一种，第二种都好理解，一一对应，第三种为什么是合法的呢？这样理解，对象本身是可以被改变的，只是不能通过我这个常量引用去改变它，唯一一种非法情况就是上面提到的让一个非常量引用去指向一个常量对象,下面的例子很有意思，也证明了常量引用去引用非常量对象是多么鸡肋

不能通过常量引用去改变非常量对象

但是如果非常量对象自己变了，常量引用也会变

```c++
const int ci = 12;
int cp = 11; 
const int &r1 = ci; //正确：引用是常量，引用的对象也是常量
int &r2 = cp; //正确：非常量引用指向非常量对象 
const int &r3 = cp;//正确：常量引用指向非常量对象 
int &r2 = ci; //错误：试图让一个非常量引用指向一个常量对象
```

 这时候有个问题了，在第三种情况中，如果我改变了cp的值，那r3的值会变吗？答案是会变的。 **严格来说，并不存在常量引用，因为引用本身不是一个对象，所以我们没办法让引用本身不变。**



<font size=5>**初始化和对const的引用 **</font>

 之前我们学到过，**引用的类型必须与其所引用的对象类型一致**，这里就有意外情况了，哦，不，例外情况，其实我们上面的第三种情况不就是例外吗？ 

```c++
int cp = 11;
const int &r3 = cp;
```

 官方说法是这样的：**在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可**。 **可以看到在引用中专门为常量引用开了后门**

```c++
double pi = 3.14;
const int &ri = pi; //正确
```

 此处ri引用了一个int型的数，对ri的操作应该是整数运算，但pi是double，因此，编译器是这么干的： 

```c++
const int temp = pi;
const int &ri = temp; //当然输出ri的话就是3了。
```

 也就是说ri其实没有绑定到pi上，而是绑定到了一个**临时对象**上，那么下面这种情况合法吗？ 

```c++
double pi = 3.14;
int &ri = pi; //错误
```

 有两种解释都可以说明它是错的，第一，**在没有const的情况下，引用和它的对象类型不匹配所以错了**，第二，**如果合法的话，程序员肯定想用ri去改变pi的值，而实际上ri是绑定到了一个临时变量，根本改变不了pi1的值，所以就非法了**。

**如果是引用绑定到临时变量的话，那么用const引用去引用不同类型的变量就是没意义的了，根本改变不了那个值**



#### 指针和const 

 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针不能用于改变其所指的对象**，所以要想存放常量对象的地址，只能使用指向常量的指针： 

```c++
const double pi = 3.14; //pi是常量，值不能被改变
double *ptr = &pi; //错误：ptr是普通指针
const double *cptr = &pi; //正确：cptr可以指向一个常量,cptr并不是常量指针，是指向常量的指针
*cptr = 3.15; //错误：不能给常量*cptr赋值
```

 之前学过，指针的类型必须与其所指的对象类型一致，例外来了： 

```c++
int i = 0;
const int *p = &i; //正确：但不能通过p来改变i的值，和引用的第三种情况差不多的
```

**这里也是指针和引用最大的区别了，引用不是对象，那一套和非常量指针是差不多的**

**但常量指针就是另说了**

指针是对象而引用不是，因此允许把指针本身定义为常量。**常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了，跟其他的const对象完全一样嘛，只不过const指针存的是地址。**

```c++
int errNumb = 0;
int *const curErr = &errNumb; //curErr将一直指向errNumb
const double pi = 3.14;
const double * const pip = &pi; //pip是指向常量对象的常量指针
```

 先看前两句，比较难理解得是第二句，还是按照以变量curErr为[最右]()端，**从右向左阅读**，最近的是const，**说明它是个常量对象**，对象的类型由声明符的其余部分确定，声明符的下一个符号是*，意味着它是个常量指针，最后它指向一个int对象。 考一考你：我们输出*curErr是0，如果我们改变了errNumb的值为1，再输出*curErr是多少呢？答案是1。 再看后两句，pip首先是一个常量，最近的是*，所以pip是个常量指针，指向什么类型呢，指向double常量。



**指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量和指针所指的对象是不是常量就是两个互相独立的问题。** 如上面代码中curErr就是指针本身是一个常量。pip是指针本身以及所指对象都是常量。下面再看些复杂点的例子 

```c++
int i = 0;
int *const p1 = &i; //指针本身是常量，采用从右到左读法就行，不能改变p1的值，
//但是可以改变i的值，只是不能通过p1去改变i的值
const int ci = 42;
const int *p2 = &ci; //指针所指的对象是常量，指针本身是普通指针，可以改变p2的值
//这么理解，p2作为普通指针存的内容是变量，但以这个内容位为地址那个是常量
//于是*p2 = 2这样企图改变常量的话是违法的
const int *const p3 = p2; //p3本身是常量指针，指向的对象是int常量
const int &r = ci; //r是引用，引用的是常量对象。
```

 看到这，如果把const的引用结合起来的话，可能有些疑惑，下面我来分析下： 前面提到过，对于引用来说，有一种情况是非法的，如下 

```c++
const int i = 1;
int &j = i;
```

 如果同样的情况，但是把引用换成指针呢？ 

```c++
const int i = 1;
int *j = &i;
```

 也是错的，简单来说，**没有const的时候(说的是引用和指针的定义是的对象类型)，只要考虑类型是否匹配就好了**，这两种情况都不匹配，所以错了。 再看两种 

```c++
const int i = 1;
const int &j1 = i;
const int *j2 = &i;
```

 类型匹配，完全正确 再来两种 

```c++
int i = 1;
const int &j1 = i;
int const &j2 = i;
const int *j3 = &i;
int const *j4 = &i;
```

 这里的四个j定义是否正确呢，答案是全部正确

j2本身是一个**常量引用**，但它引用的是变量，就是我们之前说的：指向常量的指针或引用，不过是指针或引用自以为是罢了。 指针的情况与引用类似，不再赘述。 C++的设计者搞出了两个概念： 

 **顶层const**：**指针本身是常量** 

 **底层const**：**指针所指的对象是常量** 记着就好，**顶层是本身，底层为所指**，**顶层和底层是修饰const的，不是修饰变量的** **用于声明引用的const都是底层const，为什么呢，因为引用又不是对象，没有本身，所以只好全是底层了。**

**只要等号左边的对象是常量，那指针或引用怎么都行，如果对象是常量，指针和引用必须是常量。**

#### constexpr和常量表达式

**常量表达式(**const expression)是指值不会改变并且在**编译过程**就能得到计算结果的表达式。 一个对象或表达式是不是常量表达式由它的数据类型和初始值共同决定 

```c++
const int a = 20; //是
const int b = a+1; // 是
int c = 27; //不是，因为int
const int d = get_size(); //不是，因为在运行时才能得到d的值
```

可以看到**编译初始化**和**运行初始化**带来的不同

当系统很复杂时，我们很难分辨一个初始值到底是不是常量表达式，所以C++11新标准想了个办法，允许将变量声明为constexpr类型来让**编译器验证变量的值是否是一个常量表达式** 

```c++
constexpr int a = 20; //对
constexpr int b = a + 1; //对
constexpr int sz = size(); //只有当size是一个constexpr函数时才正确，先不要管constexpr函数是啥。。。
```

 ***一般来说，如果你认定变量是一个常量表达式，那就把它声明为constexpr类型。***

**在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。**

**也就是q肯定是指向i的，q存的地址不能变，但是i其实后面是可以变得**

```c++
const int i = 0;
const int *p = &i; //p是一个指向整型常量的指针
constexpr int *q = &i; //q是一个指向整型的常量指针
```

 注意：**i得定义在函数体之外（毕竟要在编译时就确定q的值）**



## 类型别名

我们要给类型取个另外的名字，为什么这么干呢？大概是怕有些类型太复杂了

```c++
typedef double wages; //wages和double一样
typedef wages base, *p; //base=double, p=*double
```

新标准又搞了个差不多的

```c++
using Si = int; //SI和int一样
Si a = 1; //等价于int a = 1;
```

==既然有了个新东西，那指针又要来搞事情了==

```c++
typedef char *x;
const x cstr1 = 0;
const char *cstr2 = 0;
```

这里的两个cstr一样吗？ 不一样：**cstr1是指向char的常量指针**，**cstr2是指向const char的指针**，所以，不能直接用char *来代替x，怎么理解呢？ 当我们typedef了x之后，x的含义虽然是char* ，但x本身已经作为一个基本数据类型无法分割了，所以const x cstr1这句话理解的时候，**应该把x当成int之类的来理解**，**这样const就是顶层的**，说明它本身是常量，所以cstr1是个常量指针，指向char。 再来个稍微复杂的

```
const x *ps;
```

ps是一个指针，它指向的对象是：**指向char的常量指针**。

#### auto类型说明符（万能）

```c++
auto a = b; //在不清楚b是什么类型的情况下，用auto，编译器会帮我们分析b的类型
```

这个auto是不是超级好用，什么都可以装，于是，下面看看它带来的麻烦： 编译器推断出的auto类型有时候和初始值的类型并不完全一样,**其实就是对于const的东西最好不要用auto**

```c++
int i = 0;
int &r = i;
auto a = r; //a是int
//注意，auto一般会忽略顶层const，但保留底层const，
//也就是说忽略本身是常量，保留所指的是常量
const int ci = i; //顶层const
const int &cr = ci; //底层const
auto b =ci; //b是int，忽略了顶层const
auto c = cr; //c是int，虽然cr是底层const，但cr只是ci的别名，ci本身是顶层const
auto d = &i; //d是整型指针
auto e = &ci; //对对象取地址是底层const，所以e是指向整型常量的指针
```

如果强行希望推断出的auto类型是顶层const，需要明确指出

```c++
const auto f = ci; //ci的推断类型是int，但f是const int
```

看一下引用的情况，设置类型为auto引用时，顶层const仍然保留

```c++
auto &g = ci; //g是整型常量引用
auto &h = 42; //错误：42推断出int，等价于 int &h = 42,非常量引用去引用常量，违法
const auto &j = 42; //可以
```

##### decltype类型指示符

我们使用auto可以万能，但我们不知道具体是什么类型，比如

```c++
auto a = b; //肯定合法，但是你知道a是啥类型吗
```

于是，C++设计者们又搞了个好东西，函数decltype，它的作用是**返回操作数的数据类型**,**可以返回引用也是厉害....**

```c
const int ci = 0, &cj = ci;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; //y的类型是const int &，绑定到x
decltype(cj) z; //错，z是个引用，必须初始化
```

 **注意！**  **引用从来都是作为其所指对象的同义词出现，只有用在decltype处是个例外** 再来点复杂的：

```c++
int i = 42, *p = &i, &r = i;
decltype(r+1) b; //正确：加法表达式结果为int
decltype(*p) c; //错误：
//表达式的内容是解引用，则函数返回引用，等价于int &c，引用未被初始化
```

下面是一种神奇的情况：

```c++
decltype(i) d; //正确
decltype((i)) e; //错误
//编译器将(i)作为一个表达式处理，返回引用
```

 **总结：decltype((i)) 的结果永远是引用，而decltype(i)只有当i本身是引用的时候才是引用。**

### 自定义数据结构

自定义数据结以关键字class(或struct)开始，紧跟着类名和实体，**最后的分号不能省略**

自定义数据结构是**自然事物的抽象表达**，比如我们可以定义一个数据结构用来表示人当我们关注人的姓名、身高、体重时，数据结构可以这样定义：

```c++
class Person  
{  
    std::string sName;  
    double dHeight;  
    double dWeight;  
};
```

**数据成员**

- 数据成员定义了类的对象的具体内容
- 每个对象有自己的一份数据成员拷贝

**头文件** 头文件通常包含那些**只能被定义一次的实体**，如**类、const变量和constexpr变量**等

头文件存在**多次包含**的情况（直接和间接），编译器会把**头文件中的内容拷贝到包含文件中**，而我们又要确保头文件中的内容不被多次定义。

这需要用到*头文件保护符* 

```c++
//SalesData.h
#ifndef SALES_DATA_H  
#define SALES_DATA_H  
struct Sales_data  
{  
};  
#endif
```

预处理器在这里发挥了很大的作用。 ->#ifndef是“如果没有定义”的意思，SALES_DATA_H是“预处理变量”，

1. **如果没有定义SALES_DATA_H，定义SALES_DATA_H，执行下面的代码直到endif** 
2. **如果SALES_DATA_H已经定义过，则后面的代码不会执行。** 

这样确保头文件被多次包含时，其中的内容不会被多次定义。

## 补充

- 'A'长度为1 但是”A“长度为2 因为"A”=“A\0”。这里其实是有歧义的，因为这里的是字面值常量，如果他赋给char* 类型，他的长度就是2，因为C语言总会对字符串的结尾加上\0；但如果赋给string，他的长度还是1，因为C++不会在size()的返回结果是加上那个\0. 

- 引用可以理解为：**当定义引用时，程序把引用和它的初始值绑定在了一起，而不是将初始值拷贝给引用。** **引用不是一个对象 不能定义引用的引用 但是指针可以** **对于*和&可以区分为 数据类型后的为声明用的 表达式中的为取地址或者解引用用的**

- **空指针就是nullptr,0,NULL** **无效指针不是空指针，所以初始化的时候可以初始化为空指针，来保证安全**

```c++
int *p; int *&r=p; //离变量名最近的符号对变量的类型有最直接的影响 所以r是一个引用 是p指针的引用
```

