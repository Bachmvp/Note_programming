# C++ primer section3

## 字符串、向量和数组

**string**支持**可变长字符串**（注意，是可变长的），后者则表示**可变长的集合**（可以把**vector**看成是一个容器）。还会介绍一种标准库类型是**迭代器**，它是**string和vector的配套类型**，用于访问string中的字符或vector中的元素。

第二章介绍的内置类型是由C++语言**直接定义**的。这些类型**体现了大多数计算机硬件本身具备的能力**。标准库定义了另外一组更具有高级性质的类型，如string，vector等，它们尚未直接实现到计算机硬件中。

### 命名空间的using声明

目前为止，我们用到的库函数基本都属于命名空间std

```c++
using namespace std; //这样就可以访问std中所有的名字，但是很多用不到，
//可能程序开销会变大
```

##### 头文件不应包含using声明

我们用头文件一般是自定义数据类型吧（有待讨论） 因为头文件的内容在编译时会被拷贝到所有引用它的文件中去，如果头文件中有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，很有可能产生一些冲突。

### string

string表示可变长的字符序列，使用string必须包含下述代码： 

```c++
#include <string>
using std::string;
```

####  定义和初始化string对象 

```c++
string s1; //s1默认初始化，是一个空字符串
string s2 = s1; //s2是s1的副本
string s3(s2); //s3是s2的副本
string s4 = "hello"; //字符串字面值赋值
string s5(3, 'c'); //s5 = "ccc";
```

 对于s1我有个小问题，**s1和""相等吗**？于是我试了下 

```c++
string a;
string b = "";
if(a == b)
{
    cout << "equal" << endl;
}
```

 答案是**相等**的。

下面来看一个我觉得很累赘的定义 

**直接初始化和拷贝初始化** 

```c++
string s6 = "world"; //拷贝初始化
string s7("heihei"); //直接初始化
string s8(3, 'c'); //直接初始化
```

 不知道大家发现规律没，**如果原来内存中已经有一个对象，例如"world"字面值常量，然后把这个对象的内容拷贝给string，那就是拷贝初始化(其实很像第二章说的赋值初始化啊)，如果没有，就是直接初始化**

```c++
string s9 = string(10, 'c'); //拷贝初始化，因为等号右边创建了一个临时对象，s9吃的是临时对象吐给它的
```

**string对象上的操作**

**读写string** 

```c++
int main()
{
    string s;
    cin >> s;
    cout << s << endl;
    return 0;
```

 这段代码先定义一个空字符串s，然后将标准输入的内容读取到s中。**在执行读取操作时，string对象会自动忽略开头的空白（空格，换行，制表）并从第一个真正的字符开始读起，直到遇见下一处空白为止。** 如上所述，如果输入" hey zhou "，输出将是"hey"，不信你自己试试。 string对象也支持连续输入输出（这个是cin和cout的特性，以后会介绍原理） 

```c++
string s1, s2;
cin >> s1 >> s2; //第一个输入到s1，第二个输入到s2
cout << s1 << s2 << endl; //输出两个string对象
```

 这段程序如果输入" hey zhou "，输出是"heyzhou" 只有这样的一种输入方式肯定不够，因为它只能读取数量确定的一个一个的单词。

**这里还是很特殊的，所以对于和控制台的交互，尤其是输入，如果输入到string中，只定义一个string，他就是会只接受一个单词，因为我们打单词会有空格，如果用多个string可以接受多个。而流也是类似，只不过流会以空格为间隔存储多个的**

有时候，我们还希望能在最终得到的字符串中保留输入的空白符，这时应该用**getline**函数代替>>。 

```c++
int main()
{
    string line;
    while(getline(cin, line))
    {
        cout << line << endl;
    }
    return 0;
}
```

**这样就可以带空格都输入进一个string里**

**size函数和empty函数**

很明显，我们可以看到，empty()返回的是布尔类型，那么size函数返回的是int吗？如果是int，那我们之前提过，int在不同机器上的大小是不一样的，所以，这里C++的设计者搞了种新的数据类型size_type，它是**无符号类型**，就是非负数，可以做到机器无关，那么我们要这么繁琐地写这么多字母吗？不用的，别忘了我们有神器 

```c++
auto len = line.size() //len的类型是string::size_type
```

**比较string对象** 

```
string s1 = "hello";
string s2 = "hello jay";
string s3 = "hi";
```

 s1<s2<s3.

**首先是一个数位一个数位的比，相等比下一个，如果都相同长的那个大**

**为string对象赋值** 

```c++
string str = "Hello", str1;
str1 = str; //str1初始化的时候是空字符串，现在被赋值后是"Hello"，这个跟直接
string str1 = "Hello"//还是有区别的
```

**两个string对象相加** 

```c++
string s1 = "Hello", s2 = " jay";
s1 += s2; //s1 = s1 + s2，s1的内容变为hello jay
```

**字面值和string对象相加** 

 准则：**当把string对象和字符字面值及字符串字面值混在一条语句中时，必须确保每个加法运算符两侧的运算对象至少有一个是string**： 

```c++
string s1 = "hello", s2 = "jay";
string s3 = s1 + ", " + s2; //正确
string s4 = "hello" + "jay"; //错误：两个运算对象都不是string
string s5 = s1 + ", " + "jay"; //正确：第一个加号的结果就是string
string s6 = "hello" + ", " + s2; //错误
```

这个确实是，因为字面值的字符串不一定是string类型啊，可能是char* 呢，那就不支持+

#### 处理string对象中的字符 

 这个问题分两个： 

1.  处理单个字符： 比如检查一个string对象是否包含空白，或者把大写改为小写 
2.  如何获取字符本身： 有时需要处理所有字符，有时需要处理某个特定字符 关于第一个问题，除了你自己处理之外，C++中的cctype文件提供了很多方便的函数供你调用

**处理每个字符**

统计一个string对象中标点符号的个数： 

```c++
string s("hello, this is mike, nice to meet you.");
decltype(s.szie()) cnt = 0;
for(auto c : s)
{
    if(ispunct(c))
    {
        ++cnt;
    }
}
cout << "标点符号的个数是" << cnt << endl;
```

ispunct（）方便的函数，找标点符号



如果我想把一个string对象中的**小写字母都改成大写**呢？，看看下面的代码对不对 

```c++
string s("hello");
for(auto c : s)
{
    c = toupper(c);
}
cout << s << endl;
```

 很遗憾，**是错的**，因为c是由s中的字符**拷贝**过去的，意思就是，s里面有很多小苹果，c没从里面拿苹果，而是拷贝了其中一个小苹果，然后把这个拷贝的苹果变大了，跟s没啥关系。 其实只需要改一个地方就好 

```c++
string s("hello");
for(auto &c : s)
{
    c = toupper(c);
}
cout << s << endl;
```

 这时c没有去拷贝苹果，c就是里面那些小苹果的绰号，代表本身，这时就能愉快打印出"HELLO"了。

**这里之前有个误区，因为以为for(auto w:s)是不能改变里面东西的，其实是不能删增，也就是不改变位置和容量，但元素值是可以改变的，但需要用引用**

**只处理一部分字符——>下标运算符[ ]**

那[ ]符号中的数是什么类型的呢？是int吗？不是的，是string的size_type， 如果某个索引是带符号类型的值将自动转换成string的size_type。

### 标准库类型vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。可以把vector看成一个容器，容器里面装的都是同一个类型的东西。 要想使用vector，必须包含适当的头文件

```c++
#include <vector>
using std::vector;
```

C++语言有**类模板(class template)**，类模板本身不是类，可以讲类模板看成编译器生成类的说明，在我的理解中情况是这样的：

```c++
graph LR
类模板-->类
graph LR
类-->对象
```

**类模板实例化为类，类实例化为对象。** 对于类模板来说，我们需要提供一些额外的信息来指定类模板到底实例化成什么样的类。

#### 定义和初始化vector对象

下面列出了所有的初始化方法，挑顺手的用就行，不过都得看得懂别人的代码

```c++
vector<int> v1; //默认初始化，空vector
vector<int> v2(v1); 
vector<int> v3 = v1;
vector<string> v4(5, "c"); //有5个字符串"c"
vector<int> v5(5); //包含了5个重复执行默认初始化的对象，就是5个0
vector<int> v6{1, 2, 3};
vector<int> v7 = {1, 2, 3};
```

下面搞点花样，不清楚的看代码注释，清楚的看看就好了

```c++
vector<string> v1("a", "b"); //错误
vector<string> v2{"a", "b"}; //正确：列表初始化

vector<int> v3(10, -1); //正确：10个-1
vector<int> v4{10, -1}; //正确：10，-1

vector<int> v5(10); //10个0，值默认初始化
vector<string> v6(10); //10个空string对象
```

**不能用下标形式添加元素，添加元素暂时只能用Push_back，下标只是提供一种访问元素的方式，换句话说，下标只能访问元素，不能创造添加元素**(哈希表可以就是了)

### 迭代器

前面我们介绍了可以使用下标运算符来访问string对象的字符和vector对象的元素，这部分我们来介绍一种更通用的机制，迭代器。 为什么要在下标运算符之外再搞出个迭代器呢？因为所有的标准库容器都可以使用迭代器，但其中只有少数几种才同时支持下标运算，
 **总之，迭代器更普遍，更吊。**

**在STL定义的容器中， string，vector与deque提供了随机访问迭代器，list、 set、multiset、map、multimap提供了双向迭代器**

**1.所有迭代器都应该实现自增算符：iter++,++iter**

**2.Bidirectional迭代器：是在前向迭代器的基础上，多了单步向后遍历的能力。也就是--iter,iter--。**

**3.Random Access迭代器：在双向迭代器基础上，具有直接访问各数据元素的能力。随机迭代器增加了“迭代器算术运算”：**

**其实总结下来就是，双向迭代器可以自增自减，随机访问迭代器更牛逼可以增减某个特定数值**





比如我们要输出vector中所有的元素

```c++
vector<string> str = {"a", "b", "c"};
for(auto it = str.begin(); it != str.end(); ++it)
{
    cout << *it << endl;
}
```

我们来分析一下这段代码，开始是列表初始化一个vector<string>对象，关键语句在for循环中，先让it指向str的首元素，当它不等于str.end()时，输出它，并++，其中begin返回指向第一个元素的迭代器，注意它返回的是迭代器，不是元素本身，所以在访问它的时候，比如下面输出它，要加一个解引用迭代器*，end返回容器最后一个元素的下一个位置，也就是说，该迭代器指示的是容器中一个本不存在的尾后元素，虽然没什么实际含义，但是方便我们写循环啊。++it使得it后移一位，指向下一个元素。

##### 迭代器类型

就像不知道string和vector的size_type成员到底是什么类型一样，我们也不知道（而且无须知道，对，就是这么）能不能有auto之外的定义方式呢？有的，如下：

```c++
vector<int>::iterator it; //it能读写vector<int>的元素
vector<int>::const_iterator is; //is只能读vector<int>的元素
```

 *一般我们说迭代器这个名词，有三种不同的含义，在不同语境下你会知道它什么意思的：一是迭代器概念本身，二是容器定义的迭代器类型，三是某个迭代器对象。*

**begin和end运算符**

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); //it1的类型是vector<int>::iterator
auto it2 = cv.begin(); //it2的类型和it1不一样哦，是vector<int>::const_iterator
```

为了便于专门得到**const_iterator**（为什么要专门得到它呢，**因为这样通过迭代器就只能访问而不能修改了，相当于实现了只读，比较安全**），C++11开始引入了两个新函数：

```c++
auto it3 = v.cbegin();
auto it4 = v.cend();
//不管v是不是const的，二者都是const_iterator
```

### 数组 

 数组和vector非常类似，也是用于存放类型相同的对象，不同的地方在于，**数组的大小确定不变，不能随意向数组中增加元素。**因为数组的大小固定，因此对某些特殊的应用来说，程序的运行时性能较好，但是相应的也损失了一些灵活性。

#### 定义和初始化内置数组 

 值得注意的是，数组中**元素的个数**也是数组类型的一部分，编译的时候维度应该是已知的，也就是说，**维度必须是一个常量表达式** ，**还是vector更好啊**

```c++
int arr[10]; //含有十个整数的数组，默认初始化都为0
unsigned cnt = 10; //搞了半天unsigned == unsigned int，作者装什么逼。。。
constexpr unsigned f = 10; //
string good[f]; //正确
string bad[cnt]; //错误：cnt不是常量表达式
```

 为了避免程序出现什么低级错误，好的习惯是显式初始化数组元素，下面来看看这五花八门的初始化方式： 

```c++
const unsigned sz = 3;
int a1[sz] = {0, 1, 2}; //含有三个元素的数组，元素值分别为0，1，2
int a2[] = {0, 1, 2}; //与a1等价
int a3[5] = {0, 1, 2}; //等价于a3[] = {0, 1, 2, 0, 0}
string a4[3] = {"hi", "bye"}; //等价于a4[] = {"hi", "bye", ""}
int a5[2] = {0, 1, 2}; //错误：初始值过多
```

 **总结一下就是，元素不足我可以帮你补，维度不知道我可以推断，但元素多了就不行了。**

**只有在用字符串字面值初始化数组时，编译器会在最后面加一个空字符'\0'**

**发现之前理解还是有偏差啊，不是所有的初始化方式都会加空字符，只有用字面值初始化的时候才加空字符，虽然之前说的情景也是字面值**

```c++
char a1[] = {'C', '+', '+'}; //列表初始化，后面没有空字符
char a2[] = "C++"; //自动添加空字符
char a[3] = "C++"; //错误：维度不够，没办法存放空字符
```

 ***数组还有个奇怪的地方是：不允许拷贝和复制，换句话说，你只能初始化它**

**<font color=red>记住从右到左看，有括号先看括号，是不是跟四则运算差不多啊，就是这里是从右到左。 </font>**

**对于声明地方的规则就要这么记住**

```c++
int *ptrs[10]; //ptrs是数组，数组里面的元素类型是int *
int (*parray)[10]; //parray是指针，指向含有10个元素的数组

int &refs[10] = ptrs; //ref是数组，数组里面的元素是引用，
//难道就这么简单？不是的——>因为引用不是对象，这个定义错了
int (&arrRef)[10] = arr; //arrRef是一个引用，引用了一个含有10个整数的数组
```

 来个难点的，只要按照上面的基本法就可以，不要慌 

```c++
int *(&arry)[10] = ptrs; //首先看括号，括号里表示arry是个引用，括号看完了
//接下来从右往左看，引用的对象是一个大小为10的数组，最后看左边知道
//数组的元素类型是指针，指向的类型是int
```

##### 指针和数组 

 像其他对象一样。**对数组的元素使用取地址符就能得到指向该元素的指针**： 

```c++
string nums[] = {"1", "2", "3"};
string *p1 = &nums[1] //p1指向2
```

 数组还有一个特性，在很多用到数组名字的地方，**编译器会自动将数组名字替换为指向数组首元素的指针**： 

```c++
string *p0 = nums; //等价于string p0 = &nums[0];
```

 就因为这个，接下来的代码就需要你好好看看了： 

```c++
int a[] = {0, 1, 2};
auto a2(a); 
//a是数组名，所以会被转化为指针，指向0，初始化a2，也就是说a2是int *，指向a[0]
//等价于auto a2(&a[0]);
//但是，当使用decltype关键字时，上述转换不会发生
decltype(a) a3 = {3, 4, 5};
//这里decltype的参数虽然是数组名，但是它还是会返回整型数组int[3]
//注意，数组的类型包括它的维度哦，这里列表初始化的元素最多就是3个
a3[2] = 7; //修改a3数组元素的值，与a无关了哦
```

**用指针遍历数组,这里算是对上面的一个验证，数组是挺烦的，C语言用的都挺烦的** 

```c++
int arr[] = {0, 1, 2, 3};
int *p = arr; //p指向首元素
int *e = &arr[4] //e指向尾后元素，虽然看着不舒服，但是C++也支持这么做
for(int *b = p; b != e; ++b)
{
    cout << *b << endl;
}
```

### ***数组

其实C++语言中没有***数组，*****数组其实就是数组的数组。 当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个表示其元素（也是数组）大小，其实可以理解为一个表格**：

相比之下vector是真好使....

作者：苍井玛利亚

```c++
int a[3][4]; //大小为3的数组，每个元素是含有4个整数的数组
int arr[10][20][30] = {0};
//大小为10的数组，它的每个元素都是大小为20的数组
//这些数组的元素是含有30个整数的数组
//所有元素初始化为0
```

##### ***数组的初始化

```c++
int a[3][4] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} }; //这样看很好理解吧三行四列
int b[3][4] = {0, 1, 2, 3, 4, 5,6, 7, 8, 9, 10, 11}; //等价于a
int c[3][4] = { {0}, {4}, {8} }; //显式地初始化每行的首元素，其他默认初始化为0
int d[3][4] = {0, 3, 6, 9}; //显式初始化第一行，其他元素执行默认初始化
```

##### ***数组的下标引用

```c++
a[2][3] = arr[0][0][0]; //用arr的首元素为a的最后一行最后一个元素赋值
//数组a[3][4]的最后一个元素是a[2][3]哦
int (&row)[4] = a[1]; //把row绑定到a的第2行上
```

再举一个例子，程序中经常会用到两层嵌套的for循环来处理***数组的元素

```c++
contexpr size_t row = 3, col = 4;
int a[row][col];  //12个默认初始化的元素，都是0
for( size_t i=0; i<row; ++i)
{
    for(size_t j=0; j<col; ++j)
    {
        a[i][j] = 1; //都赋值为1
    }
}
```

也可以用auto来写，效果是一样的，随你高兴

```c++
for(auto &row : a)
{
    for(auto &col : row)
    {
        col = 1;
    }
}
```

在上面的例子中，因为要改变元素的值，**所以我们选择引用类型作为循环控制变量**，其实呢，还有一个更深层次的原因，来，慢慢看 **比如我们不打算修改a的元素值，只是输出它们，也得要引用**，假设没有引用，我们来看一下

```c++
for(auto row : a)
{
    for(auto col : row)
    {
        cout << col << endl;
    }
}
```

如果你觉得这样就可以的话，就太年轻了，**这样编译是会出错的**，因为row没有用引用，所以编译器对于数组名字的解释就变成了该数组首元素的指针，这样得到的row类型就是int*，显然，内层col的循环就不合法了，**编译器试图在一个int内遍历，肯定错了**。 

 **要使用auto的for循环，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**

##### 指针和***数组

当程序使用***数组的名字时，也会自动将其转换成指向数组首元素的指针，不要忘了***数组实际上是数组的数组，所以啊***数组名转换来的指针实际上是指向

**第一个内层数组的指针：**

```c++
int a[3][4];
int (*p)[4] = a; //p指向a的首行，即含有4个整数的数组，圆括号必不可少的哦
p = &a[2]; //p指向a的尾元素
```

**遍历输出的不同写法**：**这里要好好看一看**

**p指向第一个子数组，row0**

**p+1指向第二个子数组，row1**

**q=*p;指向子数组的第一个数，也就是说p虽然指向第一个子数组，但他并不指向第一个子数组的第一个元素，他指向的是整个数组，而他的对象才是sub_arr[],它指向的对象是这个数组名，也是第一个元素的地址**

```c++
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
for( auto p = a; p != a+3; ++p ) //p指向含有四个整数的数组
{
    for( auto q = *p; q != *p+4; ++q)
    {
        cout << *q << endl;
    }
}
```

或者：

```c++
for( auto p = begin(a); p != end(a); ++p ) //p指向含有四个整数的数组
{
    for( auto q = begin(*p); q != end(*p); ++q)
    {
        cout << *q << endl;
    }
}
```

使用auto关键字能让我们不用关心***数组的元素类型是啥。