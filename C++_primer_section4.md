# C++ primer section4

## 表达式

C++定义了两个概念：

- 一元运算符：作用于一个运算对象，如取地址符&
- 二元运算符：作用于两个运算对象，如乘法运算符 *一些符号两种都行，比如*乘法是二元，解引用是一元。

##### 左值和右值 

 这是两个非常难搞的概念，这里我就借用作者的话，他概括得很好：
**当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份。**
 不同的运算符对运算对象的要求各不相同，有的需要左值运算对象，有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。一个重要的原则是：**在需要右值的地方可以用左值代替，但不能把右值当成左值使用**，也就是说，身份可以当值，值不能表示身份。

**身份就是内存中的位置，值就是内存中的内容，你知道了左值，也就是内存中的位置**，当然可以拿到那个内容，所以左值能代替右值，但是你知道了内容，你是找不到地址的，因为可能很多内存地址的内容都是这个右值啊。

- 赋值运算符需要左值作为其左侧运算对象，得到的结果也是左值 

-  取地址作用于左值，返回一个指向该运算对象的指针，这个指针是右值 

-  内置解引用，下标，迭代器解引用的求值结果都是左值 

-  递增递减作用于左值，前置版本例如++i得到结果也是左值

求余还有些注意的地方： **m%(-n) = m%n; (-m)%n = -(m%n) 简单来说，就是n的符号省略，m的符号放括号外面。**

#### 逻辑和关系运算符 

| 运算符   | 功能   |
| -------- | ------ |
| !        | 逻辑非 |
| &&       | 逻辑与 |
| 两个竖杠 | 逻辑或 |

 其他如 <,>,<=,>=,!=,==都可以望文生义 &&和||都是**短路求值**，什么意思呢，比如求a&&b，如果a为假，编译器就不会去判断b的真假，因为结果肯定是假的

因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意向不到的结果： 

```c++
int i = 0, j = 5, k = 2;
if(i<j<k) //条件为真，i<j为真，值为1,1<k,对的，其实不管i和j的值，这个条件都对
if(i<j && j<k) //正确写法，这里就是false了
```

#####  相等性测试与布尔字面值 

```c++
if(val) //只要val不是零，都是true就算val是double的0.5也是真
```

##### 递增和递减运算符 

```c++
int i1 = 1, j1 = 1;
int i2 = ++i1; //i2 = 2, i1 = 2
int j2 = j1++; //j2 = 1, j1 = 2，注意与上一句话的差别
```

 在for循环中单用i++和++i完全一样，只有在上面代码那种情况下才不一样，单用的时候我们推荐++i，因为**++i将对象本身作为左值返回**，节省资源吧**，i++则将对象原始值的副本作为右值返回**。

### 位运算符 
位运算符作用于**整型类型**的运算对象，并把对象看成是二进制。标准库中有一个类型**bitset**也可以使用

运算符 | 功能

  ~ | 求反 

  << | 左移 

  \>> | 右移 

  & | 位与 

  ^ | 位亦或 

  \| | 位或 

### 移位运算符 

 ```c++
unsigned char a = 0233; //8进制010/011/011 
a << 8; //因为要左移八位，先提升为int，原先空的位数用0补齐 
a << 31; //假设机器是32位，那过头的直接丢弃 
a >> 3; //[最右]()边三位被丢弃 

a = ~a; //a = 11111111 11111111 11111111 01101000 

unsigned char b1 = 0145 //八进制 
unsigned char b2 = 0257  
b1 & b2 //24个高阶位都为0,00100101，都为1才为1 
b1 | b2 //24个高阶位都为0,11101111，一个为1就是1 
b1 ^ b2 //24个高阶位都为0,11001010，不同为1 
 ```

### sizeof运算符 

  返回一条表达式或一个类型名称所占的字节数，如果是对指针解引用使用sizeof，就会返回指针所指对象所占的字节数，而且指针不需要有效，因为sizeof不会去管内容是什么，它只是根据类型返回内存大小罢了

sizeof(ia);返回所占的字节数
sizeof ia;返回的是类型的大小 sizeof 是不会实际计算运算对象大小的，很安全
sizeof 1.对于char 返回1 

2.对于**引用类型**返回引用对象大小

3.对于**指针**返回指针本身大小

4.对于**指针解引用**返回对象大小

5.对于**数组会返回整个大小，不会当成指针处理**

6.对于**string和vector只返回固定部分的大小**，不会计算占用多少空间

7.sizeof **返回一个常量** 可以作为数组的维度的定义

 ## 类型转换

#### 隐式类型转换 

 不需要你关心，编译器会帮你搞定： 

```c++
int a = 3.5 + 3.6; //a=7
```

 算术类型之间的隐式转换原则是尽量**避免损失精度**。 我的感觉是，隐式转换都很自然，我们之前也碰到过，只不过没提到这个概念，在这里我就不一一分析了，感觉不知道这个概念，就这么自然地用也挺好的，不过后面我觉得有必要提这个概念的地方我还是会说明的。

#### 显式转换 

 有时我们希望显式地将对象强制转换成另外一种类型： 

```c++
int i = 2, j = 1;
double k = j / i;
```

 *虽然有时候不得不使用强制类型转换，但我们还是要尽量避免使用它* 强制类型转换有四种

##### 1.static_cast 

 任何具有明确定义的类型转换，只要不包含底层const（所指对象为常量），都可以使用它： 

```c++
double k = static_cast<double>(j) / i; //把j转换成double就行了
```

 两种情况常用static_cast： 

1.  把一个**较大的算术类型赋值给较小的类型**，我们用static_cast相当于告诉编译器，我们**不在乎精度损失**。 

2.  static_cast对于编译器无法自动执行的类型转换也很有用，什么意思呢？看代码： 

   ```c++
   void* p = &d; //任何非常量对象的地址都能存入void*
   double *dp = static_cast<double*>(p); //转换回来，成为double*
   ```

这个对于一般的显示转换够用了

##### 2.const_cast 

 作用只有一个，**去除底层const**，而且你只能用它来去除： 

```c++
const char *pc; //pc指向const char，是底层const
char *p = const_cast<char*>(pc); //p是*char，去除了底层const
```

对于已经指向常量的指针，想转换这种情况必须用这个

##### 旧式强制类型转换

它在不同地方用起来跟前面三者都有相似的地方，是因地制宜的一个用法，要用到的时候去查一下就好了。

```c++
int *pi;
char *pc = (char*) pi;
```

